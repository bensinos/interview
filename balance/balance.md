# 负载均衡算法

复杂均衡算法在微服务的架构中，占据非常重要的位置。比如，我们有用户服务3个，那么我们在进行请求分发的时候，应该选择哪一个呢？应该如何选择，让每台服务器的请求是均衡的？

负载均衡算法，一般分为两类，一类是静态负载均衡算法，另一类是动态负载均衡算法。

## 静态负载均衡算法

静态负载均衡算法，依靠统计学上的“最合适”

### 轮训

- 实现过程中，要注意并发安全，使用锁来管理随机数的生成
- 每个服务都依次调用，请求分配很均衡，但是实际部署中，每台服务器的处理能力是不同的，因此，会造成有个服务器负载很高，有的则很空闲
- [见代码](./round_robin.go)

### 平滑加权轮训

- 平滑加权是在轮询的基础上，加上了权重，让请求可以根据，每台服务器的权重，为每台服务器分配不同的请求量，Nginx的http负载算法，就是平滑加权轮训, [代码-703行](https://github.com/nginx/nginx/blob/master/src/http/ngx_http_upstream_round_robin.c)
- 那么如何设置权重呢？可以按照cpu的核数来进行设置，比如，有两台服务器，它们的cpu核数分别是4和16。那么在分配权重的时候，就是4:16
- 同样在动态调整时的步长，要均匀不如，10，20等
- 每个节点的权重都有上下限，下限不能为0，否则该节点，永远也无法被分配请求。上限也不能太高，否则该节点就会一直承受重大压力。一般为2～3倍即可
- [见代码](./smooth_round_robin.go)

### 随机

- 使用随机算法生成随机值
- 该方法会不均衡
- 实现时需要保证并发安全
- [代码](./random_balancer.go)

### 加权随机

通俗易懂的例子：分蛋糕假设我们有三台服务器，权重代表了它们在木板上占据的长度：

- 服务器 A (权重 5)：占 5 厘米
- 服务器 B (权重 3)：占 3 厘米
- 服务器 C (权重 2)：占 2 厘米

整个木板的总长度是 $5 + 3 + 2 = 10$ 厘米。现在，你闭上眼睛，手里拿着一把飞镖，随机扎在木板上的某个位置（这就是生成的随机数 $R$，范围是 0 到 10）。

为什么是“不断减去”？假设你的飞镖扎在了 7 厘米 的位置（$R = 7$）。
我们要找出这个位置属于谁：

1. 检查 A：A 只有 5 厘米长。

- 计算：$7 - 5 = 2$。
- 结果：$R$ 依然大于 0，说明飞镖跳过了 A，还在剩下的木板里。

2. 检查 B：B 有 3 厘米长。

- 计算：$2 - 3 = -1$。
- 结果：$R$ 变成了负数！ 这说明飞镖扎中的位置就在 B 的这 3 厘米范围内。

结论： 当 $R < 0$ 时，意味着随机数落在了当前服务器所代表的“势力范围”内。

[代码](./random_weight.go)